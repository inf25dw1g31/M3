# Capítulo 3 – Implementação e Funcionalidades

Este capítulo descreve a implementação técnica do sistema Car4Me, detalhando o desenvolvimento do backend (LoopBack 4), frontend (React Admin) e a integração entre componentes.

---

## 3.1 Implementação do Backend (LoopBack 4)

O backend Car4Me foi desenvolvido utilizando **LoopBack 4**, seguindo o tutorial **"LoopBack 4"** do Professor Marco Amaro Oliveira (Universidade da Maia), disponível na documentação oficial em https://loopback.io/doc/en/lb4/.

### 3.1.0 Metodologia de Desenvolvimento Seguida

O desenvolvimento do projeto Car4Me seguiu **passo a passo** a estrutura do tutorial LoopBack 4, aplicando os mesmos comandos e conceitos, mas adaptados ao domínio de rent-a-car em vez de school schedule.

**Tutorial base seguido:**
- **LPBK01** — Criação da aplicação base com Model, Datasource, Repository e Controller
- **LPBK02** — Implementação de relações 1:N (hasMany e belongsTo)
- **LPBK03** — Integração com MySQL como camada de persistência

**Comandos LoopBack 4 utilizados:**

```bash
# 1. Criar aplicação Car4Me
lb4 app
# Nome: car4me
# Descrição: Sistema de Gestão de Rent-a-Car

# 2. Criar models (7 entidades)
lb4 model
# Entities: Categoria, Veiculo, Cliente, Funcionario, Reserva, Manutencao, ClienteFavorito

# 3. Criar datasource MySQL
lb4 datasource
# Nome: db
# Connector: MySQL
# Configuração: variáveis de ambiente (DB_HOST, DB_USER, etc.)

# 4. Criar repositories (7 repositories)
lb4 repository
# Um repository para cada model

# 5. Criar controllers (7 controllers + 1 relação M:N)
lb4 controller
# Controllers com CRUD automático

# 6. Criar relações
lb4 relation
# hasMany: Veiculo → Reservas
# belongsTo: Reserva → Veiculo
# hasManyThrough: Cliente ↔ Veiculo (Favoritos)
```

**Equivalência Tutorial → Car4Me:**

| Conceito Tutorial | Implementação Car4Me |
|-------------------|----------------------|
| Schedule (entity) | Categoria, Veiculo, Cliente, Funcionario, Reserva, Manutencao |
| Lesson (entity) | Relações 1:N (Reservas, Manutenções) |
| hasMany (Schedule → Lesson) | hasMany (Veiculo → Reservas, Cliente → Reservas) |
| belongsTo (Lesson → Schedule) | belongsTo (Reserva → Veiculo, Reserva → Cliente) |
| In-memory datasource | MySQL 8.0 em container Docker |
| hasManyThrough (M:N) | Cliente ↔ Veiculo (tabela clientes_favoritos) |
| Datasource local | Datasource com variáveis de ambiente Docker |

### 3.1.1 Estrutura de Pastas

A estrutura de pastas gerada automaticamente pelo LoopBack 4 CLI seguiu o padrão ensinado no tutorial:

```
Car4Me_loop/car4me/
├── src/
│   ├── controllers/           # Gerados com lb4 controller
│   │   ├── categoria.controller.ts
│   │   ├── veiculo.controller.ts
│   │   ├── cliente.controller.ts
│   │   ├── funcionario.controller.ts
│   │   ├── reserva.controller.ts
│   │   ├── manutencao.controller.ts
│   │   └── cliente-favorito.controller.ts
│   ├── models/                # Gerados com lb4 model
│   │   ├── categoria.model.ts
│   │   ├── veiculo.model.ts
│   │   ├── cliente.model.ts
│   │   ├── funcionario.model.ts
│   │   ├── reserva.model.ts
│   │   ├── manutencao.model.ts
│   │   └── cliente-favorito.model.ts
│   ├── repositories/          # Gerados com lb4 repository
│   │   ├── categoria.repository.ts
│   │   ├── veiculo.repository.ts
│   │   └── ...
│   ├── datasources/           # Gerado com lb4 datasource
│   │   └── db.datasource.ts
│   └── application.ts         # Configuração da aplicação
├── package.json
└── tsconfig.json
```

**Processo de criação seguido (exemplo para Veículo):**

```bash
# 1. Criar o Model Veiculo
$ lb4 model

? Model class name: veiculo
? Please select the model base class: Entity (A persisted model with an ID)
? Allow additional (free-form) properties? No

# Adicionar propriedades uma a uma:
? Enter the property name: id_veiculo
? Property type: number
? Is id_veiculo the ID property? Yes
? Is id_veiculo generated automatically? Yes

? Enter the property name: marca
? Property type: string
? Is it required? Yes

? Enter the property name: modelo
? Property type: string
? Is it required? Yes

? Enter the property name: matricula
? Property type: string
? Is it required? Yes

# ... continuar para todos os campos (ano, cor, quilometragem, estado, id_categoria)

# 2. Criar o Repository
$ lb4 repository

? Please select the datasource: DbDatasource
? Select the model(s) you want to generate a repository: Veiculo
? Please select the repository base class: DefaultCrudRepository

# 3. Criar o Controller com CRUD automático
$ lb4 controller

? Controller class name: veiculo
? What kind of controller would you like to generate? REST Controller with CRUD functions
? What is the name of the model to use with this CRUD repository? Veiculo
? What is the name of your CRUD repository? VeiculoRepository
? What is the name of ID property? id_veiculo
? What is the type of your ID? number
? Is the id omitted when creating a new instance? Yes
? What is the base HTTP path name of the CRUD operations? /veiculos
```

Este processo foi repetido para cada uma das 7 entidades do sistema.

```
Car4Me_loop/car4me/
├── src/
│   ├── controllers/           # Endpoints REST
│   │   ├── cliente.controller.ts
│   │   ├── veiculo.controller.ts
│   │   ├── categoria.controller.ts
│   │   ├── reserva.controller.ts
│   │   ├── funcionario.controller.ts
│   │   ├── manutencao.controller.ts
│   │   └── cliente-favorito.controller.ts  # Relação M:N
│   ├── models/                # Definições TypeScript
│   │   ├── cliente.model.ts
│   │   ├── veiculo.model.ts
│   │   ├── categoria.model.ts
│   │   ├── reserva.model.ts
│   │   ├── funcionario.model.ts
│   │   ├── manutencao.model.ts
│   │   └── cliente-favorito.model.ts
│   ├── repositories/          # Acesso a dados
│   │   ├── cliente.repository.ts
│   │   ├── veiculo.repository.ts
│   │   └── ...
│   ├── datasources/           # Configuração BD
│   │   └── db.datasource.ts
│   └── application.ts         # Configuração app
├── package.json
└── tsconfig.json
```

### 3.1.2 Models (Definição de Entidades)

Os **models** definem a estrutura das entidades e o mapeamento para a base de dados.

**Exemplo: Cliente Model**

```typescript
import {Entity, model, property, hasMany} from '@loopback/repository';
import {Reserva} from './reserva.model';
import {Veiculo} from './veiculo.model';

@model({
  settings: {
    mysql: {table: 'clientes'}
  }
})
export class Cliente extends Entity {
  @property({
    type: 'number',
    id: true,
    generated: true,
    mysql: {
      columnName: 'id_cliente',
      dataType: 'int',
      nullable: false
    }
  })
  id_cliente?: number;

  @property({
    type: 'string',
    required: true,
    mysql: {columnName: 'nome', dataType: 'varchar', dataLength: 100}
  })
  nome: string;

  @property({
    type: 'string',
    required: true,
    mysql: {columnName: 'email', dataType: 'varchar', dataLength: 150}
  })
  email: string;

  @property({
    type: 'string',
    mysql: {columnName: 'telefone', dataType: 'varchar', dataLength: 20}
  })
  telefone?: string;

  @property({
    type: 'string',
    required: true,
    mysql: {columnName: 'nif', dataType: 'varchar', dataLength: 20}
  })
  nif: string;

  @property({
    type: 'string',
    mysql: {columnName: 'morada', dataType: 'varchar', dataLength: 255}
  })
  morada?: string;

  // Relações
  @hasMany(() => Reserva, {keyTo: 'id_cliente'})
  reservas: Reserva[];

  @hasMany(() => Veiculo, {through: {model: () => ClienteFavorito}})
  veiculosFavoritos: Veiculo[];

  constructor(data?: Partial<Cliente>) {
    super(data);
  }
}
```

**Características:**
- `@model()` — Decorator que marca a classe como entidade
- `@property()` — Define campos e mapeamento MySQL
- `@hasMany()` — Define relações 1:N
- `through` — Define relação M:N via tabela de junção

---

### 3.1.3 Repositories (Acesso a Dados)

Os **repositories** fornecem métodos para interagir com a base de dados.

**Exemplo: Cliente Repository**

```typescript
import {inject, Getter} from '@loopback/core';
import {
  DefaultCrudRepository,
  repository,
  HasManyRepositoryFactory,
  HasManyThroughRepositoryFactory
} from '@loopback/repository';
import {DbDataSource} from '../datasources';
import {Cliente, Reserva, Veiculo, ClienteFavorito} from '../models';
import {ReservaRepository} from './reserva.repository';
import {ClienteFavoritoRepository} from './cliente-favorito.repository';
import {VeiculoRepository} from './veiculo.repository';

export class ClienteRepository extends DefaultCrudRepository<
  Cliente,
  typeof Cliente.prototype.id_cliente
> {
  public readonly reservas: HasManyRepositoryFactory<
    Reserva,
    typeof Cliente.prototype.id_cliente
  >;

  public readonly veiculosFavoritos: HasManyThroughRepositoryFactory<
    Veiculo,
    typeof Veiculo.prototype.id_veiculo,
    ClienteFavorito,
    typeof Cliente.prototype.id_cliente
  >;

  constructor(
    @inject('datasources.db') dataSource: DbDataSource,
    @repository.getter('ReservaRepository')
    protected reservaRepositoryGetter: Getter<ReservaRepository>,
    @repository.getter('ClienteFavoritoRepository')
    protected clienteFavoritoRepositoryGetter: Getter<ClienteFavoritoRepository>,
    @repository.getter('VeiculoRepository')
    protected veiculoRepositoryGetter: Getter<VeiculoRepository>,
  ) {
    super(Cliente, dataSource);
    
    this.veiculosFavoritos = this.createHasManyThroughRepositoryFactoryFor(
      'veiculosFavoritos',
      veiculoRepositoryGetter,
      clienteFavoritoRepositoryGetter,
    );
    
    this.reservas = this.createHasManyRepositoryFactoryFor(
      'reservas',
      reservaRepositoryGetter,
    );
  }
}
```

**Funcionalidades automáticas:**
- `find()` — Listar com filtros
- `findById()` — Buscar por ID
- `create()` — Criar registo
- `updateById()` — Atualizar
- `deleteById()` — Eliminar

---

### 3.1.4 Controllers (Endpoints REST)

Os **controllers** expõem endpoints HTTP e implementam a lógica de negócio.

**Exemplo: Veículo Controller (parcial)**

```typescript
import {
  Count,
  CountSchema,
  Filter,
  FilterExcludingWhere,
  repository,
  Where,
} from '@loopback/repository';
import {
  post,
  param,
  get,
  getModelSchemaRef,
  patch,
  put,
  del,
  requestBody,
  response,
} from '@loopback/rest';
import {Veiculo} from '../models';
import {VeiculoRepository} from '../repositories';

export class VeiculoController {
  constructor(
    @repository(VeiculoRepository)
    public veiculoRepository: VeiculoRepository,
  ) {}

  // POST /veiculos
  @post('/veiculos')
  @response(200, {
    description: 'Veiculo model instance',
    content: {'application/json': {schema: getModelSchemaRef(Veiculo)}},
  })
  async create(
    @requestBody({
      content: {
        'application/json': {
          schema: getModelSchemaRef(Veiculo, {
            title: 'NewVeiculo',
            exclude: ['id_veiculo'],
          }),
        },
      },
    })
    veiculo: Omit<Veiculo, 'id_veiculo'>,
  ): Promise<Veiculo> {
    return this.veiculoRepository.create(veiculo);
  }

  // GET /veiculos/count
  @get('/veiculos/count')
  @response(200, {
    description: 'Veiculo model count',
    content: {'application/json': {schema: CountSchema}},
  })
  async count(@param.where(Veiculo) where?: Where<Veiculo>): Promise<Count> {
    return this.veiculoRepository.count(where);
  }

  // GET /veiculos
  @get('/veiculos')
  @response(200, {
    description: 'Array of Veiculo model instances',
    content: {
      'application/json': {
        schema: {
          type: 'array',
          items: getModelSchemaRef(Veiculo, {includeRelations: true}),
        },
      },
    },
  })
  async find(
    @param.filter(Veiculo) filter?: Filter<Veiculo>,
  ): Promise<Veiculo[]> {
    return this.veiculoRepository.find(filter);
  }

  // GET /veiculos/{id}
  @get('/veiculos/{id}')
  @response(200, {
    description: 'Veiculo model instance',
    content: {
      'application/json': {
        schema: getModelSchemaRef(Veiculo, {includeRelations: true}),
      },
    },
  })
  async findById(
    @param.path.number('id') id: number,
    @param.filter(Veiculo, {exclude: 'where'})
    filter?: FilterExcludingWhere<Veiculo>,
  ): Promise<Veiculo> {
    return this.veiculoRepository.findById(id, filter);
  }

  // PATCH /veiculos/{id}
  @patch('/veiculos/{id}')
  @response(204, {description: 'Veiculo PATCH success'})
  async updateById(
    @param.path.number('id') id: number,
    @requestBody({
      content: {
        'application/json': {
          schema: getModelSchemaRef(Veiculo, {partial: true}),
        },
      },
    })
    veiculo: Partial<Veiculo>,
  ): Promise<void> {
    await this.veiculoRepository.updateById(id, veiculo);
  }

  // DELETE /veiculos/{id}
  @del('/veiculos/{id}')
  @response(204, {description: 'Veiculo DELETE success'})
  async deleteById(@param.path.number('id') id: number): Promise<void> {
    await this.veiculoRepository.deleteById(id);
  }
}
```

**Endpoints gerados automaticamente:**
- `POST /veiculos` — Criar veículo
- `GET /veiculos` — Listar todos (com filtros)
- `GET /veiculos/count` — Contar registos
- `GET /veiculos/{id}` — Obter por ID
- `PATCH /veiculos/{id}` — Atualizar parcial
- `PUT /veiculos/{id}` — Substituir completo
- `DELETE /veiculos/{id}` — Eliminar

---

### 3.1.5 Relação Many-to-Many (Cliente-Favoritos)

Seguindo o conceito de **hasManyThrough** ensinado no tutorial (última página do PDF sobre relações M:N), foi implementada a relação Many-to-Many entre Clientes e Veículos.

**Processo seguido:**

```bash
# 1. Criar o Model da tabela de junção
$ lb4 model

? Model class name: clienteFavorito
? Model base class: Entity
? Allow additional properties? No

# Propriedades (chave composta):
? Property name: id_cliente
? Property type: number
? Is it the ID? Yes
? Is it required? Yes

? Property name: id_veiculo
? Property type: number
? Is it the ID? Yes
? Is it required? Yes

# 2. Criar o Repository
$ lb4 repository

? Datasource: DbDatasource
? Model: ClienteFavorito
? Repository base class: DefaultCrudRepository

# 3. Criar a relação hasManyThrough (Cliente → Veiculo)
$ lb4 relation

? Please select the relation type: hasManyThrough
? Please select source model: Cliente
? Please select target model: Veiculo
? Please select through model: ClienteFavorito
? Foreign key name that references source model: id_cliente
? Foreign key name that references target model: id_veiculo
? Source property name for the relation getter: veiculosFavoritos
? Allow Cliente queries to include data from related Veiculo instances? Yes

# 4. Criar a relação inversa (Veiculo → Cliente)
$ lb4 relation

? Relation type: hasManyThrough
? Source model: Veiculo
? Target model: Cliente
? Through model: ClienteFavorito
? Foreign key (source): id_veiculo
? Foreign key (target): id_cliente
? Source property name: clientesQueFavoritaram
? Allow Veiculo queries to include Cliente instances? Yes

# 5. Criar Controller dedicado para a tabela de junção
$ lb4 controller

? Controller class name: clienteFavorito
? Controller type: REST Controller with CRUD functions
? Model: ClienteFavorito
? Repository: ClienteFavoritoRepository
? ID property: id_cliente (nota: chave composta requer tratamento especial)
? Base HTTP path: /cliente-favoritos
```

**Nota importante sobre chaves compostas:**

Como o LoopBack 4 não suporta nativamente chaves primárias compostas, foi necessário adaptar o controller manualmente:

```typescript
// Substituir findById que espera um único ID
// POR findOne com where clause

// ANTES (gerado automaticamente - não funciona)
async findById(@param.path.number('id') id: number) {
  return this.clienteFavoritoRepository.findById(id);
}

// DEPOIS (adaptado manualmente)
async findById(
  @param.path.number('id_cliente') id_cliente: number,
  @param.path.number('id_veiculo') id_veiculo: number
) {
  const favorito = await this.clienteFavoritoRepository.findOne({
    where: {id_cliente, id_veiculo}
  });
  
  if (!favorito) {
    throw new HttpErrors.NotFound('Favorito não encontrado');
  }
  
  return favorito;
}
```

Esta adaptação foi uma das **dificuldades encontradas** (documentada no Capítulo 4), pois o tutorial não cobria explicitamente este caso.

**Model: ClienteFavorito**

```typescript
import {Entity, model, property} from '@loopback/repository';

@model({
  settings: {
    mysql: {table: 'clientes_favoritos'},
    strict: false
  }
})
export class ClienteFavorito extends Entity {
  @property({
    type: 'number',
    required: true,
    id: true,
    mysql: {columnName: 'id_cliente', dataType: 'int'}
  })
  id_cliente: number;

  @property({
    type: 'number',
    required: true,
    id: true,
    mysql: {columnName: 'id_veiculo', dataType: 'int'}
  })
  id_veiculo: number;

  constructor(data?: Partial<ClienteFavorito>) {
    super(data);
  }
}
```

**Controller: ClienteFavoritoController**

```typescript
import {Count, CountSchema, Filter, repository, Where} from '@loopback/repository';
import {del, get, getModelSchemaRef, param, post, requestBody, response} from '@loopback/rest';
import {ClienteFavorito} from '../models';
import {ClienteFavoritoRepository} from '../repositories';

export class ClienteFavoritoController {
  constructor(
    @repository(ClienteFavoritoRepository)
    public clienteFavoritoRepository: ClienteFavoritoRepository,
  ) {}

  // POST /cliente-favoritos
  @post('/cliente-favoritos')
  @response(200, {
    description: 'ClienteFavorito model instance',
    content: {'application/json': {schema: getModelSchemaRef(ClienteFavorito)}},
  })
  async create(
    @requestBody({
      content: {
        'application/json': {
          schema: getModelSchemaRef(ClienteFavorito, {
            title: 'NewClienteFavorito',
          }),
        },
      },
    })
    clienteFavorito: ClienteFavorito,
  ): Promise<ClienteFavorito> {
    return this.clienteFavoritoRepository.create(clienteFavorito);
  }

  // GET /cliente-favoritos/count
  @get('/cliente-favoritos/count')
  @response(200, {
    description: 'ClienteFavorito model count',
    content: {'application/json': {schema: CountSchema}},
  })
  async count(
    @param.where(ClienteFavorito) where?: Where<ClienteFavorito>,
  ): Promise<Count> {
    return this.clienteFavoritoRepository.count(where);
  }

  // GET /cliente-favoritos
  @get('/cliente-favoritos')
  @response(200, {
    description: 'Array of ClienteFavorito model instances',
    content: {
      'application/json': {
        schema: {
          type: 'array',
          items: getModelSchemaRef(ClienteFavorito, {includeRelations: true}),
        },
      },
    },
  })
  async find(
    @param.filter(ClienteFavorito) filter?: Filter<ClienteFavorito>,
  ): Promise<ClienteFavorito[]> {
    return this.clienteFavoritoRepository.find(filter);
  }

  // GET /cliente-favoritos/{id_cliente}/{id_veiculo}
  @get('/cliente-favoritos/{id_cliente}/{id_veiculo}')
  @response(200, {
    description: 'ClienteFavorito model instance',
    content: {
      'application/json': {
        schema: getModelSchemaRef(ClienteFavorito, {includeRelations: true}),
      },
    },
  })
  async findById(
    @param.path.number('id_cliente') id_cliente: number,
    @param.path.number('id_veiculo') id_veiculo: number,
  ): Promise<ClienteFavorito> {
    const favorito = await this.clienteFavoritoRepository.findOne({
      where: {id_cliente, id_veiculo}
    });
    
    if (!favorito) {
      throw new HttpErrors.NotFound('Favorito não encontrado');
    }
    
    return favorito;
  }

  // DELETE /cliente-favoritos/{id_cliente}/{id_veiculo}
  @del('/cliente-favoritos/{id_cliente}/{id_veiculo}')
  @response(204, {description: 'ClienteFavorito DELETE success'})
  async deleteById(
    @param.path.number('id_cliente') id_cliente: number,
    @param.path.number('id_veiculo') id_veiculo: number,
  ): Promise<void> {
    await this.clienteFavoritoRepository.deleteAll({
      id_cliente,
      id_veiculo
    });
  }
}
```

**Desafios da chave composta:**
- LoopBack 4 não suporta nativamente chaves compostas
- Solução: usar `findOne()` com `where` em vez de `findById()`
- Usar `deleteAll()` com filtro em vez de `deleteById()`

---

## 3.2 Implementação do Frontend (React Admin)

O frontend foi desenvolvido com **React Admin**, que fornece componentes prontos para dashboards administrativos.

### 3.2.1 Estrutura do Projeto

```
car4me-react_admin/
├── public/
├── src/
│   ├── App.js                  # Configuração principal
│   ├── dataProvider.js         # Comunicação com API
│   ├── i18n/
│   │   └── pt.js               # Traduções PT-PT
│   └── resources/
│       ├── categorias.jsx
│       ├── clientes.jsx
│       ├── veiculos.jsx
│       ├── funcionarios.jsx
│       ├── reservas.jsx
│       ├── manutencoes.jsx
│       ├── cliente-favoritos.jsx
│       └── Dashboard.jsx
├── package.json
└── Dockerfile
```

### 3.2.2 Configuração Principal (App.js)

```javascript
import { Admin, Resource, ListGuesser } from 'react-admin';
import polyglotI18nProvider from 'ra-i18n-polyglot';
import portugueseMessages from './i18n/pt';
import dataProvider from './dataProvider';

// Icons
import CategoryIcon from '@mui/icons-material/Category';
import DirectionsCarIcon from '@mui/icons-material/DirectionsCar';
import PeopleIcon from '@mui/icons-material/People';
import WorkIcon from '@mui/icons-material/Work';
import BookIcon from '@mui/icons-material/Book';
import BuildIcon from '@mui/icons-material/Build';
import FavoriteIcon from '@mui/icons-material/Favorite';

// Components
import Dashboard from './resources/Dashboard';
import { CategoriaList, CategoriaEdit, CategoriaCreate, CategoriaShow } from './resources/categorias';
import { ClienteList, ClienteEdit, ClienteCreate, ClienteShow } from './resources/clientes';
import { VeiculoList, VeiculoEdit, VeiculoCreate, VeiculoShow } from './resources/veiculos';
import { FuncionarioList, FuncionarioEdit, FuncionarioCreate, FuncionarioShow } from './resources/funcionarios';
import { ReservaList, ReservaEdit, ReservaCreate, ReservaShow } from './resources/reservas';
import { ManutencaoList, ManutencaoEdit, ManutencaoCreate, ManutencaoShow } from './resources/manutencoes';
import { ClienteFavoritoList, ClienteFavoritoCreate, ClienteFavoritoShow } from './resources/cliente-favoritos';

const i18nProvider = polyglotI18nProvider(() => portugueseMessages, 'pt');

const App = () => (
  <Admin
    dataProvider={dataProvider}
    i18nProvider={i18nProvider}
    dashboard={Dashboard}
  >
    <Resource
      name="categorias"
      list={CategoriaList}
      edit={CategoriaEdit}
      create={CategoriaCreate}
      show={CategoriaShow}
      icon={CategoryIcon}
      options={{ label: 'Categorias' }}
    />
    <Resource
      name="veiculos"
      list={VeiculoList}
      edit={VeiculoEdit}
      create={VeiculoCreate}
      show={VeiculoShow}
      icon={DirectionsCarIcon}
      options={{ label: 'Veículos' }}
    />
    <Resource
      name="clientes"
      list={ClienteList}
      edit={ClienteEdit}
      create={ClienteCreate}
      show={ClienteShow}
      icon={PeopleIcon}
      options={{ label: 'Clientes' }}
    />
    <Resource
      name="funcionarios"
      list={FuncionarioList}
      edit={FuncionarioEdit}
      create={FuncionarioCreate}
      show={FuncionarioShow}
      icon={WorkIcon}
      options={{ label: 'Funcionários' }}
    />
    <Resource
      name="reservas"
      list={ReservaList}
      edit={ReservaEdit}
      create={ReservaCreate}
      show={ReservaShow}
      icon={BookIcon}
      options={{ label: 'Reservas' }}
    />
    <Resource
      name="manutencaos"
      list={ManutencaoList}
      edit={ManutencaoEdit}
      create={ManutencaoCreate}
      show={ManutencaoShow}
      icon={BuildIcon}
      options={{ label: 'Manutenções' }}
    />
    <Resource
      name="cliente-favoritos"
      list={ClienteFavoritoList}
      create={ClienteFavoritoCreate}
      show={ClienteFavoritoShow}
      icon={FavoriteIcon}
      options={{ label: 'Favoritos' }}
    />
  </Admin>
);

export default App;
```

---

### 3.2.3 DataProvider Customizado

O **DataProvider** é responsável por traduzir as operações do React Admin em chamadas HTTP para a API.

**Principais desafios:**
1. React Admin espera campo `id`, mas a API usa `id_cliente`, `id_veiculo`, etc.
2. Relação M:N precisa de IDs compostos
3. Formato de datas precisa de transformação

**Solução (dataProvider.js parcial):**

```javascript
import { fetchUtils } from 'react-admin';
import { stringify } from 'query-string';

const apiUrl = 'http://localhost:3000';
const httpClient = fetchUtils.fetchJson;

// Mapeamento de IDs
const resourceIdMap = {
  categorias: 'id_categoria',
  veiculos: 'id_veiculo',
  clientes: 'id_cliente',
  funcionarios: 'id_funcionario',
  reservas: 'id_reserva',
  manutencaos: 'id_manutencao',
  'cliente-favoritos': 'id_cliente',
};

const getIdField = (resource) => resourceIdMap[resource] || 'id';

// Normalizar dados (adicionar campo 'id')
const normalizeData = (resource, data) => {
  const idField = getIdField(resource);
  
  // Tratamento especial para cliente-favoritos (chave composta)
  if (resource === 'cliente-favoritos') {
    if (Array.isArray(data)) {
      return data.map(item => ({
        ...item,
        id: `${item.id_cliente}_${item.id_veiculo}`, // ID único combinado
      }));
    }
    return {
      ...data,
      id: `${data.id_cliente}_${data.id_veiculo}`,
    };
  }
  
  // Tratamento normal
  if (Array.isArray(data)) {
    return data.map(item => ({
      ...item,
      id: item[idField] || item.id,
    }));
  }
  return {
    ...data,
    id: data[idField] || data.id,
  };
};

export default {
  getList: (resource, params) => {
    const { page, perPage } = params.pagination;
    const { field, order } = params.sort;
    
    const query = {
      filter: JSON.stringify({
        offset: (page - 1) * perPage,
        limit: perPage,
        order: `${field} ${order}`,
        where: params.filter,
      }),
    };
    
    const url = `${apiUrl}/${resource}?${stringify(query)}`;
    
    return httpClient(url).then(({ json }) => {
      return httpClient(`${apiUrl}/${resource}/count`).then(({ json: countJson }) => ({
        data: normalizeData(resource, json),
        total: countJson.count,
      }));
    });
  },

  getOne: (resource, params) => {
    // Tratamento especial para cliente-favoritos
    if (resource === 'cliente-favoritos') {
      const [id_cliente, id_veiculo] = params.id.split('_');
      return httpClient(`${apiUrl}/${resource}/${id_cliente}/${id_veiculo}`).then(({ json }) => ({
        data: normalizeData(resource, json),
      }));
    }
    
    return httpClient(`${apiUrl}/${resource}/${params.id}`).then(({ json }) => ({
      data: normalizeData(resource, json),
    }));
  },

  create: (resource, params) => {
    // Transformar datas se necessário
    if (resource === 'manutencaos' && params.data.data_manutencao) {
      params.data.data_manutencao = new Date(params.data.data_manutencao).toISOString();
    }
    
    if (resource === 'cliente-favoritos') {
      return httpClient(`${apiUrl}/${resource}`, {
        method: 'POST',
        body: JSON.stringify(params.data),
      }).then(({ json }) => ({
        data: {
          ...json,
          id: `${json.id_cliente}_${json.id_veiculo}`
        }
      }));
    }
    
    return httpClient(`${apiUrl}/${resource}`, {
      method: 'POST',
      body: JSON.stringify(params.data),
    }).then(({ json }) => ({
      data: normalizeData(resource, json),
    }));
  },

  delete: (resource, params) => {
    // Tratamento especial para cliente-favoritos (ID composto)
    if (resource === 'cliente-favoritos') {
      const [id_cliente, id_veiculo] = params.id.split('_');
      return httpClient(`${apiUrl}/${resource}/${id_cliente}/${id_veiculo}`, {
        method: 'DELETE',
      }).then(() => ({
        data: { id: params.id }
      }));
    }
    
    return httpClient(`${apiUrl}/${resource}/${params.id}`, {
      method: 'DELETE',
    }).then(({ json }) => ({
      data: { ...json, id: params.id }
    }));
  },
  
  // ... outros métodos (update, updateMany, deleteMany, getMany, getManyReference)
};
```

---

### 3.2.4 Componente CRUD (Exemplo: Veículos)

```javascript
import React from 'react';
import {
  List, Datagrid, TextField, NumberField, Edit, Create,
  SimpleForm, TextInput, NumberInput, SelectInput,
  ReferenceInput, required, Show, SimpleShowLayout,
  ReferenceField, DeleteButton, EditButton
} from 'react-admin';

// Lista de veículos
export const VeiculoList = () => (
  <List>
    <Datagrid rowClick="show">
      <TextField source="id_veiculo" label="ID" />
      <TextField source="marca" label="Marca" />
      <TextField source="modelo" label="Modelo" />
      <TextField source="matricula" label="Matrícula" />
      <NumberField source="ano" label="Ano" />
      <TextField source="estado" label="Estado" />
      <ReferenceField source="id_categoria" reference="categorias" label="Categoria">
        <TextField source="nome" />
      </ReferenceField>
      <EditButton />
      <DeleteButton />
    </Datagrid>
  </List>
);

// Formulário de criação
export const VeiculoCreate = () => (
  <Create>
    <SimpleForm>
      <SelectInput
        source="marca"
        choices={[
          { id: 'Audi', name: 'Audi' },
          { id: 'BMW', name: 'BMW' },
          { id: 'Mercedes', name: 'Mercedes' },
          // ... 27 marcas mais
        ]}
        validate={[required()]}
      />
      <TextInput source="modelo" validate={[required()]} />
      <TextInput source="matricula" validate={[required()]} />
      <NumberInput source="ano" validate={[required()]} />
      <TextInput source="cor" />
      <NumberInput source="quilometragem" defaultValue={0} />
      <SelectInput
        source="estado"
        choices={[
          { id: 'Disponivel', name: 'Disponível' },
          { id: 'Alugado', name: 'Alugado' },
          { id: 'Manutencao', name: 'Manutenção' },
        ]}
        defaultValue="Disponivel"
      />
      <ReferenceInput source="id_categoria" reference="categorias">
        <SelectInput optionText="nome" validate={[required()]} />
      </ReferenceInput>
    </SimpleForm>
  </Create>
);

// Visualização detalhada
export const VeiculoShow = () => (
  <Show>
    <SimpleShowLayout>
      <TextField source="id_veiculo" label="ID" />
      <TextField source="marca" label="Marca" />
      <TextField source="modelo" label="Modelo" />
      <TextField source="matricula" label="Matrícula" />
      <NumberField source="ano" label="Ano" />
      <TextField source="cor" label="Cor" />
      <NumberField source="quilometragem" label="Quilometragem" />
      <TextField source="estado" label="Estado" />
      <ReferenceField source="id_categoria" reference="categorias" label="Categoria">
        <TextField source="nome" />
      </ReferenceField>
    </SimpleShowLayout>
  </Show>
);

// Edição (similar ao Create)
export const VeiculoEdit = () => (
  <Edit>
    <SimpleForm>
      {/* Mesmo conteúdo do Create, mas com TextInput disabled para id_veiculo */}
    </SimpleForm>
  </Edit>
);
```

---

### 3.2.5 Dashboard com Estatísticas

```javascript
import React from 'react';
import { Card, CardContent, CardHeader } from '@mui/material';
import { useGetList } from 'react-admin';

const Dashboard = () => {
  const { data: veiculos } = useGetList('veiculos');
  const { data: clientes } = useGetList('clientes');
  const { data: reservas } = useGetList('reservas');
  
  const veiculosDisponiveis = veiculos?.filter(v => v.estado === 'Disponivel').length || 0;
  const veiculosAlugados = veiculos?.filter(v => v.estado === 'Alugado').length || 0;
  const reservasAtivas = reservas?.filter(r => r.estado === 'ativa').length || 0;
  
  return (
    <div style={{ padding: 20 }}>
      <h1>Dashboard Car4Me</h1>
      <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr 1fr', gap: 20 }}>
        <Card>
          <CardHeader title="Veículos Totais" />
          <CardContent>
            <h2>{veiculos?.length || 0}</h2>
          </CardContent>
        </Card>
        <Card>
          <CardHeader title="Veículos Disponíveis" />
          <CardContent>
            <h2>{veiculosDisponiveis}</h2>
          </CardContent>
        </Card>
        <Card>
          <CardHeader title="Veículos Alugados" />
          <CardContent>
            <h2>{veiculosAlugados}</h2>
          </CardContent>
        </Card>
        <Card>
          <CardHeader title="Clientes" />
          <CardContent>
            <h2>{clientes?.length || 0}</h2>
          </CardContent>
        </Card>
        <Card>
          <CardHeader title="Reservas Ativas" />
          <CardContent>
            <h2>{reservasAtivas}</h2>
          </CardContent>
        </Card>
        <Card>
          <CardHeader title="Reservas Totais" />
          <CardContent>
            <h2>{reservas?.length || 0}</h2>
          </CardContent>
        </Card>
      </div>
    </div>
  );
};

export default Dashboard;
```

---

## 3.3 Testes e Validação

### 3.3.1 Testes da API

**Ferramentas utilizadas:**
- Swagger UI (`/explorer`)
- Postman
- Browser DevTools

**Cenários testados:**
1. ✅ CRUD completo para cada recurso
2. ✅ Validações de campos obrigatórios
3. ✅ Foreign keys e integridade referencial
4. ✅ Relação M:N (favoritos)
5. ✅ Triggers automáticos
6. ✅ Filtros e ordenação
7. ✅ Regras de negócio (DELETE)

**Exemplo de teste (Postman):**
```
POST /veiculos
{
  "marca": "BMW",
  "modelo": "Série 3",
  "matricula": "AA-00-AA",
  "ano": 2024,
  "cor": "Azul",
  "id_categoria": 2
}

Resposta esperada: 200 OK
{
  "id_veiculo": 101,
  "marca": "BMW",
  ...
}
```

### 3.3.2 Testes do Frontend

**Cenários testados:**
1. ✅ Navegação entre recursos
2. ✅ Criação de registos com validações
3. ✅ Edição e atualização
4. ✅ Eliminação com confirmação
5. ✅ Dashboard com estatísticas
6. ✅ Relações bidirecionais (favoritos)
7. ✅ i18n em português
8. ✅ Filtros e pesquisa

---

## 3.4 Instalação e Execução

### 3.4.1 Requisitos

- Docker 20.10+
- Docker Compose 2.0+
- 4GB RAM disponível
- Portas livres: 3007, 3000, 8080

### 3.4.2 Instalação

```bash
# 1. Clonar repositório
git clone [URL_REPOSITORIO]
cd Car4Me_Projeto

# 2. Build dos containers
docker-compose -f docker-compose.env.yml build

# 3. Iniciar sistema
docker-compose -f docker-compose.env.yml up -d

# 4. Aguardar inicialização (30-60 segundos)
docker-compose -f docker-compose.env.yml logs -f

# 5. Verificar estado
docker-compose -f docker-compose.env.yml ps
```

### 3.4.3 URLs de Acesso

| Componente | URL | Descrição |
|------------|-----|-----------|
| Frontend | http://localhost:8080 | Backoffice React Admin |
| API Explorer | http://localhost:3000/explorer | Swagger UI |
| API Ping | http://localhost:3000/ping | Health check |
| MySQL | localhost:3007 | Base de dados |

### 3.4.4 Comandos Úteis

```bash
# Ver logs em tempo real
docker-compose -f docker-compose.env.yml logs -f

# Parar sistema
docker-compose -f docker-compose.env.yml down

# Parar e apagar volumes (⚠️ apaga dados)
docker-compose -f docker-compose.env.yml down -v

# Reiniciar apenas um serviço
docker-compose -f docker-compose.env.yml restart api

# Aceder ao container
docker exec -it car4me-api sh
docker exec -it car4me-mysql mysql -ucar4me -pcar4me car4me
```

---

## 3.5 Conclusão

A implementação do sistema Car4Me demonstra:

✅ **Arquitetura sólida** — 3 camadas bem separadas  
✅ **Código TypeScript** — Type-safe e bem estruturado  
✅ **Relações complexas** — M:N implementada corretamente  
✅ **UI moderna** — React Admin com Material-UI  
✅ **Containerização completa** — Portabilidade garantida  
✅ **Documentação automática** — OpenAPI gerada pelo LoopBack  

O sistema está **pronto para produção** e pode ser facilmente expandido com novas funcionalidades.

---

[< Previous](c2.md) | [^ Main](../../../) | [Next >](c4.md)
:--- | :---: | ---:
